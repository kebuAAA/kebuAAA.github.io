<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Seaborn库简介 | 小明的博客</title><meta name="author" content="爱编程的小明"><meta name="copyright" content="爱编程的小明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#e68ab8"><meta name="description" content="将本文结合代码使用效果更佳哦❤️❤️  速查  example gallery:      Seaborn 库简介 特点:  Seaborn, a statistical graphics library created by Michael Waskom. Seaborn..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Seaborn库简介",
  "url": "https://kebuaaa.github.io/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B/",
  "image": "https://seaborn.pydata.org/_images/logo-wide-lightbg.svg",
  "datePublished": "2022-09-21T08:53:00.000Z",
  "dateModified": "2023-01-09T06:03:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "爱编程的小明",
      "url": "https://kebuaaa.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kebuaaa.github.io/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#e68ab8")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>var _hmt=_hmt||[];!function(){var t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4e3a07c287f8fb6cfc09bf5a7fdc1dd7";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(t,a)}(),btf.addGlobalFn("pjaxComplete",(()=>{_hmt.push(["_trackPageview",window.location.pathname])}),"baidu_analytics")</script><script>!function(e,t,n,c,a,i,r){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},(i=t.createElement(c)).async=1,i.src="https://www.clarity.ms/tag/e8bjif1knd",(r=t.getElementsByTagName(c)[0]).parentNode.insertBefore(i,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:1,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!0,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Seaborn库简介",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><style>#article-container.post-content h1:before,h2:before,h3:before,h4:before,h5:before,h6:before{-webkit-animation:avatar_turn_around 1s linear infinite;-moz-animation:avatar_turn_around 1s linear infinite;-o-animation:avatar_turn_around 1s linear infinite;-ms-animation:avatar_turn_around 1s linear infinite;animation:avatar_turn_around 1s linear infinite}</style><link rel="stylesheet" href="/Scripts/css/transparent.css"><link rel="stylesheet" href="/Scripts/css/font.css"><link rel="stylesheet" href="/Scripts/css/foot_style.css"><link rel="stylesheet" href="/Scripts/css/twikoo_beautify.css"><link rel="stylesheet" href="/Scripts/css/tags.css"><link rel="stylesheet" href="/Scripts/css/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg" style="background-image:url(url(/img/index_img.webp))"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/wallpaper/"><i class="fa-fw fas fa-image fa-fw"></i> <span>壁纸</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fa fa-subway"></i> <span>开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小明的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Seaborn库简介</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="/wallpaper/"><i class="fa-fw fas fa-image fa-fw"></i> <span>壁纸</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fa fa-subway"></i> <span>开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Seaborn库简介<a class="post-edit-link" href="https://github.dev/kebuAAA/myblog/blob/main/source/_posts/Seaborn库简介.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-21T08:53:00.000Z" title="发表于 2022-09-21 16:53:00">2022-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-09T06:03:00.000Z" title="更新于 2023-01-09 14:03:00">2023-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/Python%E5%BA%93/">Python库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>将本文结合<a target="_blank" rel="noopener" href="https://github.com/kebuAAA/Visualization-using-python">代码</a>使用效果更佳哦❤️❤️</p></div><h1 id="速查">速查</h1><p><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../md_imgs/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B/0.bmp" alt="数据透视表创建.png"></p><p><a target="_blank" rel="noopener" href="https://seaborn.pydata.org/examples/index.html">example gallery</a>:</p><iframe src="https://seaborn.pydata.org/examples/index.html" width="100%" height="500px" frameborder="0" name="seaborngallery"></iframe><h1 id="seaborn-库简介">Seaborn 库简介</h1><p>特点:</p><blockquote><p>Seaborn, <strong>a statistical graphics library created by Michael Waskom.</strong> Seaborn simplifies creating many common visualization types.<br>Unlike when using matplotlib directly, it wasn’t necessary to specify attributes of the plot elements in terms of the color values or marker codes. Behind the scenes, seaborn handled the translation from values in the dataframe to arguments that matplotlib understands. This declarative approach lets you stay focused on the questions that you want to answer, rather than on the details of how to control matplotlib.<br>如果给的数据表符合规范（tidy)，绘图使用会方便很多</p></blockquote><h1 id="figure-level-functions">Figure-level functions</h1><p>seaborn 支持像 matplotlib 一样针对不同的绘图类型来调用不同的函数(ax-level)，但是因为 seaborn 的代码本身是高度组织化（structured）的，更常用的是通过可视化任务的类型来调用 Figure-level 的接口函数去完成不同的<strong>可视化任务</strong>（重点不是图表类型），按照这个思路，seaborn 可以分为 distributions module、relation module 以及 category module 三个模块，每个模块都有一个<strong>figure-level</strong>的函数来帮助我们更快地完成可视化任务。<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20220929001028.png" alt="function_overview_8_0"><br>Seaborn 绘图对于统计描述支持很少，只使用较为简单的函数便可以对数据做区间估计的可视化、分布的可视化等绘图，也会依据输入的数据来自己判断轴的名称等一系列内容（choose default values for its parameters based on characteristics of the data）<br>Figure-level 级别的绘图函数并不好用来绘制不同绘图类型的子图，虽然丧失了自定义程度，但是因为高度的统一性也变得更加简单易用，这是 seaborn 绘图的一大重要特色。<br>尽管如此，seaborn 的 figure-level 也通过返回的 seaborn 对象（一般是<code>FaceGrid</code>）的 ax 属性来支持对 matplotlib 的绘图对象的访问，这样就可以通过 seaborn 的绘图函数来完成一些简单的绘图任务，然后通过对返回的对象的处理可以实现一些自定义的凑在哦，这样就可以兼顾 seaborn 的简单易用性和 matplotlib 的灵活性:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">g = sns.relplot(data=tips, x=<span class="string">&quot;total_bill&quot;</span>, y=<span class="string">&quot;tip&quot;</span>)</span><br><span class="line">g.ax.axline(xy1=(<span class="number">10</span>, <span class="number">2</span>), slope=<span class="number">.2</span>, color=<span class="string">&quot;b&quot;</span>, dashes=(<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line">g.set_axis_labels?</span><br></pre></td></tr></table></figure><h2 id="指定绘图尺寸">指定绘图尺寸</h2><p>figure-level 在指定绘图尺寸时与 matplotlib 有一点区别:</p><ul><li>该函数使用<code>height</code>和<code>aspect</code>两个参数调整绘图尺寸，<code>aspect</code>参数是指定绘图的<strong>宽高比</strong>，<code>height</code>参数是指定绘图的高度，<code>aspect</code>和<code>height</code>的乘积就是绘图的宽度。</li><li>多副图的情况下，seaborn 的 figure-level 函数传入的参数规定的是每个子图的尺寸，而不是整个 figure 的尺寸</li><li>一般可以在创建 seaborn 对象的时候进行指定</li></ul><h2 id="总结">总结</h2><p>On balance, the figure-level functions add some additional complexity that can make things more confusing for beginners, but their distinct features give them additional power. <strong>The tutorial documentation mostly uses the figure-level functions, because they produce slightly cleaner plots, and we generally recommend their use for most applications</strong>. <strong>The one situation where they are not a good choice is when you need to make a complex, standalone figure that composes multiple different plot kinds</strong>. At this point, it’s recommended to set up the figure using matplotlib directly and to fill in the individual components using axes-level functions.</p><h2 id="两个特例">两个特例</h2><p>seaborn 的 figure-level 函数中还有两个特殊的函数不能直接划入上述所说的分类中，两个函数主要是用来描述变量之间的联合分布（<code>jointplot()</code>）以及相关关系（<code>pairplot()</code>），之所以这两个函数被单列出来是因为两个函数建立了一种对数据的 multiple views，两个函数也会返回一个 seaborn 对象来帮助我们实现更多的自定义操作。<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20220930000031.png" alt="Seaborn库简介_20220930000031"></p><center>jointplot</center><p><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20220930000107.png" alt="Seaborn库简介_20220930000107"></p><center>pairplot</center><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seaborn.jointplot(data=<span class="literal">None</span>, *, x=<span class="literal">None</span>, y=<span class="literal">None</span>, hue=<span class="literal">None</span>, kind=<span class="string">&#x27;scatter&#x27;</span>, height=<span class="number">6</span>, ratio=<span class="number">5</span>, space=<span class="number">0.2</span>, dropna=<span class="literal">False</span>, xlim=<span class="literal">None</span>, ylim=<span class="literal">None</span>, color=<span class="literal">None</span>, palette=<span class="literal">None</span>, hue_order=<span class="literal">None</span>, hue_norm=<span class="literal">None</span>, marginal_ticks=<span class="literal">False</span>, joint_kws=<span class="literal">None</span>, marginal_kws=<span class="literal">None</span>, **kwargs)</span><br><span class="line">seaborn.pairplot(data, *, hue=<span class="literal">None</span>, hue_order=<span class="literal">None</span>, palette=<span class="literal">None</span>, <span class="built_in">vars</span>=<span class="literal">None</span>, x_vars=<span class="literal">None</span>, y_vars=<span class="literal">None</span>, kind=<span class="string">&#x27;scatter&#x27;</span>, diag_kind=<span class="string">&#x27;auto&#x27;</span>, markers=<span class="literal">None</span>, height=<span class="number">2.5</span>, aspect=<span class="number">1</span>, corner=<span class="literal">False</span>, dropna=<span class="literal">False</span>, plot_kws=<span class="literal">None</span>, diag_kws=<span class="literal">None</span>, grid_kws=<span class="literal">None</span>, size=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h1 id="axes-level-functions">Axes-level functions</h1><p>seaborn 的轴级函数与 matplotlib 比较相似，在创建好轴之后可以通过<code>ax=</code>参数来调整绘图的位置:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f, axs = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">8</span>, <span class="number">4</span>), gridspec_kw=<span class="built_in">dict</span>(width_ratios=[<span class="number">4</span>, <span class="number">3</span>]))</span><br><span class="line">sns.scatterplot(data=penguins, x=<span class="string">&quot;flipper_length_mm&quot;</span>, y=<span class="string">&quot;bill_length_mm&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.histplot(data=penguins, x=<span class="string">&quot;species&quot;</span>, hue=<span class="string">&quot;species&quot;</span>, shrink=<span class="number">.8</span>, alpha=<span class="number">.8</span>, legend=<span class="literal">False</span>, ax=axs[<span class="number">1</span>])</span><br><span class="line">f.tight_layout()</span><br></pre></td></tr></table></figure><p>轴上每一个位置都是一副独立的子图，这一定程度也满足了我们自定义绘图的要求。</p><p><strong>Figure-level 函数作为 seaborn 的一大特色，是在学习过程中应着重加以关注的</strong>。</p><h1 id="统计分析-replot">统计分析-replot</h1><p><strong>Visualizing statistical relationships</strong><br>sns 的<code>replot</code>主要是用来进行统计分析的一个函数，主要调用的是<code>scatterplot</code>和<code>lineplot</code>两个 axes-level 函数，可以用来分析变量之间的关系</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=<span class="literal">None</span>,</span><br><span class="line">    x=,</span><br><span class="line">    y=,</span><br><span class="line">    kind=<span class="string">&#x27;scatter&#x27;</span>,</span><br><span class="line">    col=,</span><br><span class="line">    hue=,</span><br><span class="line">    style=,</span><br><span class="line">    size=,</span><br><span class="line">    col_wrap=,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数示意:<br>这些参数都可以传入 data 的列名，以列为依据进行操作</p><ul><li><code>kind</code>: {‘line’, ‘scatter’}, optional</li><li><code>col</code>: 拆分数据集，用来创建不同的子图</li><li><code>hue</code>: 色彩语义（hue semantic）,用来确样本点的取色依据（不同值会有不同的颜色），若该列的值为连续值，默认使用渐变颜色</li><li><code>style</code>: 样式语义（style semantic）,用来确定样本点的标记格式（例如圆或者*等）</li><li><code>size</code>: 尺寸语义（size semantic）,用来确定样本点的标记大小</li><li><code>col_wrap</code>: int,每一行子图个数<br><strong>对于绘图的具体用哪些颜色或者标记点的类型等自定义化的功能，则需要根据使用的 ax-level 函数的传入参数来进行调整(例如查看 scatterplot 函数的参数说明)</strong>,上边提到的参数只能用来确定用作分类依据的列。<br>这里给出一个 scatterplot 的例子:</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Load an example dataset</span></span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line"><span class="comment">#Create a visualization</span></span><br><span class="line">sns.relplot(</span><br><span class="line">    data=tips,</span><br><span class="line">    x=<span class="string">&quot;total_bill&quot;</span>,</span><br><span class="line">    y=<span class="string">&quot;tip&quot;</span>,</span><br><span class="line">    row=,</span><br><span class="line">    col=<span class="string">&quot;time&quot;</span>,</span><br><span class="line">    hue=<span class="string">&quot;smoker&quot;</span>,</span><br><span class="line">    <span class="comment">#palette=&quot;ch:r=-.5,l=.75&quot;,#自定义化颜色</span></span><br><span class="line">    style=<span class="string">&quot;sex&quot;</span>,</span><br><span class="line">    size=<span class="string">&quot;size&quot;</span>,</span><br><span class="line">    <span class="comment">#sizes=(15, 200),#自定义数据点大小</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20220930221048.png" alt="Seaborn库简介_20220930221048"><br>由于线形图有区间估计等更加复杂的操作，因此当指定<code>kind='line'</code>时，会有一些其它特殊的参数，这里做一个简单说明：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.relplot(</span><br><span class="line">    data=fmri,</span><br><span class="line">    kind=<span class="string">&quot;line&quot;</span>,</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>,</span><br><span class="line">    y=<span class="string">&quot;signal&quot;</span>,</span><br><span class="line">    estimator=<span class="literal">None</span>,</span><br><span class="line">    errorbar=<span class="string">&quot;sd&quot;</span>,</span><br><span class="line">    units=,</span><br><span class="line">    sort=<span class="literal">True</span>，</span><br><span class="line">    orient=<span class="string">&quot;x&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于<code>lineplot</code>函数，seaborn 会根据输入的数据特征做一些默认的处理，例如对于同一个 x 有多个不同的观测值的情况，该函数会在默认情况下自动将数据聚集起来(aggregate，可以指定<code>estimator=None</code>取消),然后对样本做一个 95%的置信区间估计(可以调整<code>errorbar</code>参数选择不估计或者改为其他的估计方式)。<code>units</code>相当于一个分组键，会将分组后的数据呈现在一图中（不显示图例）。<br>sort 表示对数据是否排序，orient 表示索引轴（默认 x<br>一个例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fmri=sns.load_dataset(<span class="string">&quot;fmri&quot;</span>)</span><br><span class="line">sns.relplot(</span><br><span class="line">    data=fmri, kind=<span class="string">&quot;line&quot;</span>,</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;region&quot;</span>, style=<span class="string">&quot;event&quot;</span>,</span><br><span class="line">    dashes=<span class="literal">False</span>,</span><br><span class="line">    markers=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">sns.relplot(</span><br><span class="line">    data=fmri.query(<span class="string">&quot;region == &#x27;frontal&#x27;&quot;</span>), kind=<span class="string">&quot;line&quot;</span>,</span><br><span class="line">    x=<span class="string">&quot;timepoint&quot;</span>, y=<span class="string">&quot;signal&quot;</span>, hue=<span class="string">&quot;event&quot;</span>, style=<span class="string">&quot;event&quot;</span>,</span><br><span class="line">    col=<span class="string">&quot;subject&quot;</span>, col_wrap=<span class="number">5</span>,</span><br><span class="line">    height=<span class="number">3</span>, aspect=<span class="number">.75</span>, linewidth=<span class="number">2.5</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更加细致的自定义程度还得参考<code>lineplot</code>函数的参数说明。</p><h1 id="数据分布可视化">数据分布可视化</h1><p><code>displot</code>函数主要是对数据的分布情况进行可视化，样式的定义参数与前边提到的<code>relplot</code>函数类似，数据分布的可视化可以分为单变量数据分布可视化和两变量数据可视化，这个主要根据传入函数的<code>x</code>,<code>y</code>来确定，绘图种类有直方图、核密度估计图、ecdf 三种类型的图，都是对数据分布情况的可视化，这里只对常用的条形图的可视化参数做一个说明，其余两种类型的绘图方式见<a target="_blank" rel="noopener" href="https://seaborn.pydata.org/tutorial/distributions.html">官方文档</a>（绘图函数差别较大，很多细节的调整要查看对应的绘图函数）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.displot(data, x=<span class="string">&quot;类型&quot;</span></span><br><span class="line">            , hue=<span class="string">&#x27;纹饰&#x27;</span></span><br><span class="line">            <span class="comment"># , fill=True</span></span><br><span class="line">            <span class="comment">#,shrink=.5</span></span><br><span class="line">            <span class="comment">#,bins=4</span></span><br><span class="line">            , multiple=<span class="string">&quot;stack&quot;</span></span><br><span class="line">            ,rug=<span class="literal">False</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure><ul><li><code>shrink</code>:条形图的宽度，取值范围[0,1]，默认为 1，取值越小，条形图越窄</li><li><code>bins</code>:划分区间个数，也可以传入数字列表表示划分位置</li><li><code>multiple</code>:调整多个条形图的布局方式，取值为<code>stack</code>或者<code>dodge</code>，默认为<code>stack</code>，即堆叠，取值为<code>dodge</code>时，条形图会分开显示</li><li><code>rug</code>：边缘分布情况</li></ul><p><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%8F%AF%E8%A7%86%E5%8C%96displot().png" alt="Seaborn库简介_数据分布可视化displot()"></p><h2 id="联合分布和边缘分布可视化">联合分布和边缘分布可视化</h2><p>seaborn 的<code>jointplot()</code>函数提供了绘制二维数据的联合分布的绘图方法，通过调整<code>kind</code>参数能实现对二维数据选择各种绘图类型进行绘制，另外改图也会在联合图的正上方和右边绘制单变量的分布图，也支持对绘图方法进行自定义:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">g = sns.JointGrid(data=penguins, x=<span class="string">&quot;bill_length_mm&quot;</span>, y=<span class="string">&quot;bill_depth_mm&quot;</span>)</span><br><span class="line">g.plot_joint(sns.histplot)</span><br><span class="line">g.plot_marginals(sns.boxplot)</span><br></pre></td></tr></table></figure><h2 id="多变量分布可视化">多变量分布可视化</h2><p><code>pairplot</code>函数提供与<code>jointplot</code>相似的功能但是支持多变量的数据分布可视化。<br><code>pairplot()</code>函数支持定义对角线上边和下边使用不同的绘图方法，可以通过调整参数决定不同子图是否共享 xy 轴，具体可以查看官方文档</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">penguins = sns.load_dataset(<span class="string">&quot;penguins&quot;</span>)</span><br><span class="line">g = sns.PairGrid(penguins)</span><br><span class="line">g.map_upper(sns.histplot)</span><br><span class="line">g.map_lower(sns.kdeplot, fill=<span class="literal">True</span>)</span><br><span class="line">g.map_diag(sns.histplot, kde=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h1 id="多子图自定义">多子图自定义</h1><p>从上述<code>pairplot</code>和<code>jointplot</code>的绘图方式可以看出 seaborn 也提供了比较灵活的绘图方式，大致步骤是首先先创建一个<code>FaceGrid</code>对象，然后在该对象上调用<code>map()</code>方法，该方法接收一个绘图函数和一个或多个列名，然后在每个子图上调用该绘图函数，绘制对应的图形。<code>FacetGrid</code>对象的<code>map()</code>方法还支持传入<code>hue</code>参数，用于指定绘图时使用的颜色变量，<code>FacetGrid</code>对象的<code>add_legend()</code>方法可以在图形中添加图例。更多细节可以查看官方的<a target="_blank" rel="noopener" href="https://seaborn.pydata.org/tutorial/axis_grids.html">帮助文档</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_theme()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate an example radial datast</span></span><br><span class="line">r = np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">100</span>)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;r&#x27;</span>: r, <span class="string">&#x27;slow&#x27;</span>: r, <span class="string">&#x27;medium&#x27;</span>: <span class="number">2</span> * r, <span class="string">&#x27;fast&#x27;</span>: <span class="number">4</span> * r&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the dataframe to long-form or &quot;tidy&quot; format</span></span><br><span class="line">df = pd.melt(df, id_vars=[<span class="string">&#x27;r&#x27;</span>], var_name=<span class="string">&#x27;speed&#x27;</span>, value_name=<span class="string">&#x27;theta&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a grid of axes with a polar projection</span></span><br><span class="line">g = sns.FacetGrid(df, col=<span class="string">&quot;speed&quot;</span>, hue=<span class="string">&quot;speed&quot;</span>,</span><br><span class="line">                  subplot_kws=<span class="built_in">dict</span>(projection=<span class="string">&#x27;polar&#x27;</span>), height=<span class="number">4.5</span>,</span><br><span class="line">                  sharex=<span class="literal">False</span>, sharey=<span class="literal">False</span>, despine=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw a scatterplot onto each axes in the grid</span></span><br><span class="line">g.<span class="built_in">map</span>(sns.scatterplot, <span class="string">&quot;theta&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>axes</code>方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">f, axs = plt.subplots(<span class="number">1</span>,</span><br><span class="line">                      <span class="number">2</span>,</span><br><span class="line">                      figsize=(<span class="number">8</span>, <span class="number">4</span>),</span><br><span class="line">                      gridspec_kw=<span class="built_in">dict</span>(width_ratios=[<span class="number">4</span>, <span class="number">3</span>]))</span><br><span class="line">sns.scatterplot(data=penguins,</span><br><span class="line">                x=<span class="string">&quot;flipper_length_mm&quot;</span>,</span><br><span class="line">                y=<span class="string">&quot;bill_length_mm&quot;</span>,</span><br><span class="line">                hue=<span class="string">&quot;species&quot;</span>,</span><br><span class="line">                ax=axs[<span class="number">0</span>])</span><br><span class="line">sns.histplot(data=penguins,</span><br><span class="line">             x=<span class="string">&quot;species&quot;</span>,</span><br><span class="line">             hue=<span class="string">&quot;species&quot;</span>,</span><br><span class="line">             shrink=<span class="number">.8</span>,</span><br><span class="line">             alpha=<span class="number">.8</span>,</span><br><span class="line">             legend=<span class="literal">False</span>,</span><br><span class="line">             ax=axs[<span class="number">1</span>])</span><br><span class="line">f.tight_layout()</span><br></pre></td></tr></table></figure><h1 id="分类变量可视化">分类变量可视化</h1><p><code>catplot</code>函数主要是对分类变量的可视化，其绘图类型有<code>stripplot</code>、<code>swarmplot</code>、<code>boxplot</code>、<code>violinplot</code>、<code>boxenplot</code>、<code>pointplot</code>、<code>barplot</code>、<code>countplot</code>.<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_catplot.png" alt="Seaborn库简介_catplot"><br>绘制不同图时只需调整<code>kind</code>参数即可,其余参数与前边类似，具体的细节调整要查看对应的绘图函数来进行调整<br>感觉点图绘制的很新奇，有一点像桑葚图的感觉<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20221001210625.png" alt="Seaborn库简介_20221001210625"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titanic=sns.load_dataset(<span class="string">&#x27;titanic&#x27;</span>)</span><br><span class="line">g = sns.catplot(</span><br><span class="line">    data=titanic, x=<span class="string">&quot;class&quot;</span>, y=<span class="string">&quot;survived&quot;</span>, hue=<span class="string">&quot;sex&quot;</span>,</span><br><span class="line">    palette=&#123;<span class="string">&quot;male&quot;</span>: <span class="string">&quot;g&quot;</span>, <span class="string">&quot;female&quot;</span>: <span class="string">&quot;m&quot;</span>&#125;,</span><br><span class="line">    markers=[<span class="string">&quot;^&quot;</span>, <span class="string">&quot;o&quot;</span>], linestyles=[<span class="string">&quot;-&quot;</span>, <span class="string">&quot;--&quot;</span>],</span><br><span class="line">    kind=<span class="string">&quot;point&quot;</span></span><br><span class="line">)</span><br><span class="line">g.savefig(<span class="string">&#x27;./sns样图/分类点图.png&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="customization">customization</h1><p>Seaborn is so nice to make a beautiful plot, but sometimes we need to customize the plot to make it more beautiful. Here are some tips to customize the plot. Just remember that you can always check the documentation of the function you are using to see what <strong>parameters</strong> you can use to customize the plot. If this is not enough, may be consider the return object of the function you are using and use the methods of the object to customize the plot(diffent functions return different object, but most of time you can find a way to customize the plot using like the <code>ax</code> object in matplotlib), <code>FaceGrid</code> object is a unique object in seaborn, but you can also its <code>ax</code> attribute to customize the plot.</p><h1 id="seaborn-objects">seaborn.objects</h1><p><code>seaborn.objects</code>是 seaborn 在 v0.12 中推出的一种全新的绘图方式，借鉴 ggplot2 的思想，使用全新的 end-to-end 的链式调用法绘图，使得 seaborn 的可扩展性和自定义化程度大大提高，因为目前这个版本还是一个实验性的版本，因此这里只介绍一下这种思想，简单的代码实践可以参考<a target="_blank" rel="noopener" href="https://github.com/kebuAAA/Visualization-using-python">代码实践</a></p><p>在<code>seaborn.objects</code>中，一般的使用步骤如下</p><ol><li><p>首先实例化一个<code>Plot</code>对象，该对象可用的方法：<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20230109145916.png" alt="Seaborn库简介_20230109145916"></p></li><li><p>然后调用该对象的<code>add()</code>方法来创建一个个 layer，同时也支持通过调用<code>facet()</code>方法来创建多个子图。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plot</span>.add(mark, *transforms, orient=<span class="literal">None</span>, legend=<span class="literal">True</span>, data=<span class="literal">None</span>, **variables)</span><br></pre></td></tr></table></figure><ul><li>在每一个 layer 中，可以传入想要的绘图方式<code>so.Mark</code>类(<code>so.Dot()</code>,<code>so.Line()</code>,<code>so.Area()</code>,<code>so.Bar()</code>)来绘制想要的图形，与最初的绘图方法不同的是 seaborn.objects 会对有的绘图方式提供两种方法。以<code>so.Bar()</code>和<code>so.Bars()</code>,后者常用于 x 变量是连续变量的情况，相当于专门对这种情况做了一些优化（The plural version is typically optimized for cases with larger numbers of marks.）<br>注意对于复杂的图形，可能会多次调用 add 方法来实现更加复杂的操作(<code>Plot</code>方法也是同理)，<a target="_blank" rel="noopener" href="https://seaborn.pydata.org/tutorial/objects_interface.html#adding-multiple-layers">比如</a>先做出散点图，然后在对点进行拟合，这种叠加的效果其实也就显现出来了这种接口方式的一个优势。<blockquote><p>An important thing to know is that Plot methods clone the object they are called on and return that clone instead of updating the object in place.</p></blockquote></li></ul><blockquote><p>The Plot methods are fully declarative. Calling them updates the plot spec, but it doesn’t actually do any plotting. One consequence of this is that methods can be called in any order, and many of them can be called multiple times.</p></blockquote><p>然后可以选择传入<code>so.Stat</code>类对原始数据进行聚合操作或者传入<code>so.Move</code>类对绘图对象进行平移，二者都会被传入<code>transforms</code>参数，二类都有时有限传入<code>Stat</code><br><code>so.Stat</code>类：</p><ul><li><code>so.Agg()</code>: 需要在开始传入 x 和 y 变量，默认使用均值函数对每一组的取值（具体选择是自动决定的）进行聚合(因为涉及到分组所以一般用在类别变量+数值变量的情况)</li><li><code>so.Hist()</code>：只需在开始时传入一个变量，另外一个变量取值通过该方法的函数进行计算</li><li><code>so.Est()</code>:同时对 x 和 y 进行转换（Some transforms accept both x and y, but add interval data for each coordinate. This is particularly relevant for plotting error bars after aggregating）<br>这些方法都只是聚合数据的方法</li></ul><p><code>so.Move()</code>类:<br><code>so.Move()</code>类对绘图的对象进行移动（<code>so.Dodge()</code>, <code>so.Jitter()</code>）<br>另外也可以传入定义在这个 layer 上的参数(是否显示图例，按照哪一列进行分类，orient 参数等)。</p><p>需要强调的是<code>so</code>为色彩语义添加了更加详细的划分（引入了<code>edgecolor</code>参数）因此原来绘图中使用的<code>hue</code>也就被替换成了<code>color</code>,从这点也可以看出在引入这个接口之后 seaborn 的自定义化程度更高了。<br>注意这种绘图方式下的三个不同的定义空间</p><ul><li>定义在所有 layer 中的参数</li><li>定义在一个 layer 中的参数</li><li>定义在绘图函数中的参数（map data values to various graphical properties）</li></ul><p><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20221004130250.png" alt="Seaborn库简介_20221004130250"><br>对于图形在 notebook 中的显示，官方是这么写的:“To see a plot in a notebook, either return it from the final line of a cell or call Jupyter’s built-in display function on the object. The notebook integration bypasses matplotlib.pyplot entirely, but you can use its figure-display machinery in other contexts by calling <code>Plot.show()</code>.”<br>最后是<code>so.save</code>对绘图进行保存</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn.objects <span class="keyword">as</span> so</span><br><span class="line">(</span><br><span class="line">    so.Plot(data=<span class="literal">None</span>,</span><br><span class="line">        x=<span class="literal">None</span>,</span><br><span class="line">        y=<span class="literal">None</span>,</span><br><span class="line">        color=<span class="literal">None</span>,</span><br><span class="line">        edgecolor=<span class="literal">None</span>,</span><br><span class="line">        marker=<span class="literal">None</span>,</span><br><span class="line">        xmin=<span class="literal">None</span>,</span><br><span class="line">        fill=<span class="literal">None</span>,</span><br><span class="line">        groups=<span class="literal">None</span>)</span><br><span class="line">    .facet(col=<span class="literal">None</span>,</span><br><span class="line">        row=<span class="literal">None</span>,</span><br><span class="line">        )</span><br><span class="line">    .add()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="外观调整">外观调整</h2><p>调用该对象的<code>scale</code>、<code>label()</code>等方法来设置颜色、坐标轴、图例、marker 等图形外观属性:</p><ul><li><code>scale()</code>：设置坐标轴的范围间隔等内容（对数刻度，也可以修改所有图层的颜色,更多的查看帮助文档</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">    so.Plot(diamonds, x=<span class="string">&quot;carat&quot;</span>, y=<span class="string">&quot;price&quot;</span>, color=<span class="string">&quot;clarity&quot;</span>, pointsize=<span class="string">&quot;carat&quot;</span>)</span><br><span class="line">    .add(so.Dots())</span><br><span class="line">    .scale(color=(<span class="string">&quot;#88c&quot;</span>, <span class="string">&quot;#555&quot;</span>), pointsize=(<span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="customizing-limits-labels-and-titles">Customizing limits, labels, and titles</h3><ul><li><code>label()</code>：Control the labels and titles for axes, legends, and subplots.</li><li><code>limit</code>:坐标轴范围设置</li><li><code>share</code>:是否共享坐标轴</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">    so.Plot(diamonds, x=<span class="string">&quot;carat&quot;</span>, y=<span class="string">&quot;price&quot;</span>, color=<span class="string">&quot;carat&quot;</span>)</span><br><span class="line">    .add(so.Dots())</span><br><span class="line">    .scale(</span><br><span class="line">        x=so.Continuous().tick(every=<span class="number">0.5</span>), <span class="comment">#x轴刻度间隔设置为0.5</span></span><br><span class="line">        y=so.Continuous().label(like=<span class="string">&quot;$&#123;x:.0f&#125;&quot;</span>),<span class="comment">#y轴刻度格式设置</span></span><br><span class="line">        color=so.Continuous().tick(at=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>如果想要同时指定标签和刻度，可以写成类似<code>so.Continuous().tick(every=1).label(like=&quot;&#123;x: .0f&#125;&quot;)</code>的形式</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">    so.Plot(penguins, x=<span class="string">&quot;body_mass_g&quot;</span>, y=<span class="string">&quot;species&quot;</span>, color=<span class="string">&quot;island&quot;</span>)</span><br><span class="line">    .facet(col=<span class="string">&quot;sex&quot;</span>)</span><br><span class="line">    .add(so.Dot(), so.Jitter(<span class="number">.5</span>))</span><br><span class="line">    .share(x=<span class="literal">True</span>) <span class="comment">#x轴是否使用同一刻度</span></span><br><span class="line">    .limit(y=(<span class="number">2.5</span>, -<span class="number">.5</span>)) <span class="comment">#y轴范围设置</span></span><br><span class="line">    .label(</span><br><span class="line">        x=<span class="string">&quot;Body mass (g)&quot;</span>, y=<span class="string">&quot;&quot;</span>,</span><br><span class="line">        color=<span class="built_in">str</span>.capitalize,</span><br><span class="line">        title=<span class="string">&quot;&#123;&#125; penguins&quot;</span>.<span class="built_in">format</span>,</span><br><span class="line">    ) <span class="comment">#label个性化标题</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>An important thing to know is that Plot methods clone the object they are called on and return that clone instead of updating the object in place.</p></blockquote><h3 id="theme-customization">Theme customization</h3><p><code>theme()</code>：调节绘图参数，可以用来设置图片中文显示之类的(更新 Rc 参数)<br>截止到目前<code>seaborn.object</code>都没有全局状态的概念，这也意味着<code>sns.set_theme()</code>并不会对<code>seaborn.objects</code>的绘图功能起到作用<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20230109153031.png" alt="Seaborn库简介_20230109153031"></p><h2 id="多子图创建">多子图创建</h2><blockquote><p>简单来说<code>seaborn.object</code>接口的出现方便了 sns 的多子图绘制功能。</p></blockquote><p><code>seaborn.objects</code>为 seaborn 中多子图的绘制提供了更加方便的方法。一般来说，我们希望的多子图分为两种情况:</p><ul><li>一种情况是观察不同类别的特征差异，这种情况下我们希望不同子图的数据是某一列的不同取值，这时可以调用<code>facet()</code>方法</li><li>另外一种情况是希望比较个体不同特征的差异，这个时候不同子图的绘图变量不同，这时则可以使用<code>pair</code>方法，类似<code>PairGrid()</code><br>多子图方法相当于对在 figure 层面进行操作，因此一般先于<code>add()</code>方法调用。<br><code>facet()</code>方法可以指定绘图的行列数，以及绘图的顺序，这样就可以很好地解决多子图绘制没有那么方便的问题，若在绘制时传入类似<code>.facet(row='col_var')</code>参数，那么就可以快速实现多子图的创建，若直接在<code>Plot()</code>中指定<code>color</code>参数，就会默认绘制在一张图之上。大概差异可以看下边的图:<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20221015123743.png" alt="Seaborn库简介_20221015123743"><br>只指定<code>color</code>参数:<br><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../img/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B_20221015123658.png" alt="Seaborn库简介_20221015123658"><br>具体的绘图代码见<a target="_blank" rel="noopener" href="https://github.com/kebuAAA/Visualization-using-python">代码</a></li></ul><h2 id="结合-matplotlib">结合 matplotlib</h2><p>严格来说有了<code>pair</code>,<code>facet</code>方法后使用 seaborn 进行完整绘图已经不存在什么问题。开发者考虑到可能会有 seaborn 不能覆盖的情况，通过<code>Plot().on()</code>方法将 matplotlib 进行融合，该方法可以传入的参数是一个绘图位置的对象（This object can be either a <code>matplotlib.axes.Axes</code>, <code>matplotlib.figure.Figure</code>, or <code>matplotlib.figure.SubFigure</code>; the latter is most useful for constructing bespoke subplot layouts）,记得在最后边调用一下<code>.plot()</code>方法让图片显示出来</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://kebuaaa.github.io">爱编程的小明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://kebuaaa.github.io/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B/">https://kebuaaa.github.io/Seaborn%E5%BA%93%E7%AE%80%E4%BB%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kebuaaa.github.io" target="_blank">小明的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python%E5%BA%93/">Python库</a><a class="post-meta__tags" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/">可视化</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a><a class="post-meta__tags" href="/tags/Seaborn/">Seaborn</a></div><div class="post-share"><div class="social-share" data-image="https://seaborn.pydata.org/_images/logo-wide-lightbg.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%9F%BA%E7%A1%80/" title="时间序列基础"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/平稳时间序列建模_demo.jpg" onerror='onerror=null,src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">时间序列基础</div></div><div class="info-2"><div class="info-item-1">本篇文章由博主参考王燕老师的《应用时间序列分析》结合学校开设的《时间序列分析》课程撰写，主要用来作为考前复习，如有疏漏欢迎留言讨论。 斜体或者标题加*内容为辅助理解内容 Introduction 传统的统计学习过程中我们用样本推断总体的方法时，我们希望分析的随机变量越少越好，同时每一个变量的信息(样本容量 n)越大越好，这从两个方面保证了我们统计分析的合理性，而对于时间序列而言，因为引入了时间变量TTT，我们将每一个时刻的值都视为一个随机变量，这样的话相当于对于每一个随机变量进行分析时我们只能使用这个时刻的数据，这对于统计分析的展开是非常不利的，这个时候很容易就想到能不能将不同时刻的数据结合在一起来对每一时刻的随机变量进行一个估计，这种做法的前提就是不同时刻对应随机变量的具有某种一定的相似性，这也就引出了我们所说的“平稳性”的概念，简单来说时间序列的平稳性就是在看随机变量的分布特征是否会随着时间改变。 特征统计量 这块主要是涉及对序列统计性质的描述，基本上和数理统计学到的内容一致. 均值 方差 自协方差函数和自相关系数（Auto Correlation...</div></div></div></a><a class="pagination-related" href="/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" title="集成学习"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/../top_img/10026.webp" onerror='onerror=null,src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">集成学习</div></div><div class="info-2"><div class="info-item-1">集成学习更深入的内容可以参考周志华老师的《集成学习：基础与算法 》，限于笔者的能力和精力，过于深入的东西笔者还没有理解 许是开始就没学会，也或者是因为时间太长忘光光了，重新学习集成学习这章。 概述 集成学习(Ensemble Learning)是将多个学习器结合，构建一个有较强性能的机器学习器的方法。 集成学习的一般结构: 一组个体学习器+结合策略。一般来说集成的学习器都是弱学习器（弱学习器继承效果相对较好） 根据集成学习的各基估计器类型是否相同，可以分为同质和异质两种方法。 分类 根据每个基学习器是否同属一个种类。可以将集成学习分为同质和异质两种类型。 同质集成学习 同质表示集成的个体学习器属于同种类型，这时的个体学习器又称为基学习器。 目前来说，同质个体学习器的应用最为广泛。一般的集成学习均指同质个体学习器。而同质个体学习器使用最多的模型是 CART 决策树和神经网络。 周志华老师的《机器学习》一书中证明过若基分类器的错误率相互独立，根据 Hoeffding 不等式可得当个体分类器数目 T...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Matplotlib/" title="Matplotlib库"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://matplotlib.org/_static/images/logo2.svg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="info-item-2">Matplotlib库</div></div><div class="info-2"><div class="info-item-1">将本文结合代码使用效果更佳哦❤️❤️ matplotlib is a desktop plotting package designed for creating (mostly twodimensional) publication-quality plots. The project was started by John Hunter in 2002 to enable a MATLAB-like plotting interface in Python. Over time, matplotlib has spawned a number of add-on toolkits for data visualization that use matplotlib for their underlying plotting. One of these is...</div></div></div></a><a class="pagination-related" href="/Numpy/" title="Numpy"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10040.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="info-item-2">Numpy</div></div><div class="info-2"><div class="info-item-1">numpy(numerical Python) 是 Python 数值计算最重要的基础包，大多数提供科学计算的包都是用 NumPy 的数组为构建基础。 NumPy 可以用于数值计算的一个重要原因是因为他能处理大数组的数据： 在连续的内存块储存数据，独立于其他 Python 内置对象（C 语言编写的算法库，在 C 的基础上封装） 可以在整个数组上执行复杂的计算，不需要 for loop 速查 图片对应pdf.pdf 介绍 基本用法 NumPy 最重要的一个特点就是 ndarray(n 维数组对象，一个快速而灵活的大数据集容器) Creating ndarray python 默认创建数组的数据类型是浮点数（方便科学计算） np.array(): 支持任何序列对象 np.zeros（） np.empty()创建一个数组，值可能为 0 有些情况下为垃圾值 np.arrange():类似于内置的 range 返回一个 数组的数据类型 类型转换–np.astype 可以在创建数组时指定数值类型，也可以通过...</div></div></div></a><a class="pagination-related" href="/Pandas/" title="Pandas"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/981d48e57e23a4907cebc4eb481799b5882595ea978261f22a3e131dcd6ebee6/68747470733a2f2f70616e6461732e7079646174612e6f72672f7374617469632f696d672f70616e6461732e737667" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="info-item-2">Pandas</div></div><div class="info-2"><div class="info-item-1">放一个目录做的的思维导图 一场数模国赛下来发现对于pandas里的一些基础操作还不是很熟练，整个建模过程中用到了许多pandas中对DataFrame的索引，切片访问，分组交叉透视等功能，除此以外稍微高级一点的就是用了几次apply函数来对某一行的值进行一个计算输出，虽然知识描述统计这部分的内容，但是能明显的感觉到对于这些基本功能有些生疏。坦白来讲，pandas的描述统计相关的这些工作其实借助excel也能够实现，但是当考虑到可迁移性这些方面的内容时，使用编程语言的优越性也就自然而然地体现出来，当然，如果对相关的函数不能做到很熟悉的话，其实反而加大了工作量。 简介 Pandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为最强大、最灵活、可以支持任何语言的开源数据分析工具。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。 虽然 pandas 采用了大量的 NumPy 编码风格，但二者最大的不同是...</div></div></div></a><a class="pagination-related" href="/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8/" title="数据可视化入门"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10004.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-05</div><div class="info-item-2">数据可视化入门</div></div><div class="info-2"><div class="info-item-1">数据可视化的主要方法是借助 matplotlib 或者 Seaborn。除了这些以外，通过类似于Bokeh或者Plotly工具我们已经可以借助用浏览器创建动态可交互的图像（基于 python）。 内容简介 大部分可视化库都是利用[图形框架语法]来构建图像，可以自己定义轴，线，框这些元素，保证了高度的自由度。 五个比较关键的库： 更多细节的对比: 学习路线 matplotlib：matplotlib 的自定义化程度高，语法相对比较复杂，不作为主力可视化方法（学习成本相对较高），不过底层逻辑的一些东西要清楚，大部分可视化的库都是建立在这个库的基础之上，具体的绘图函数之类的东西不必太过认真看，有些内容调节起来过于繁琐。 Seaborn： seaborn 的语法比较简单，图形本身比较美观易用，这个库的学习主要借助官方文档，明白 seaborn 的可视化上限和自定义程度即可。 creating interactive graphics Plotly 相关说明： plotly 是一个基于 javascript 的绘图库，plotly 绘图种类丰富，效果美观； 易于保存与分享...</div></div></div></a><a class="pagination-related" href="/PyCaret/" title="PyCaret"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10005.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-31</div><div class="info-item-2">PyCaret</div></div><div class="info-2"><div class="info-item-1">PyCaret是Python中的低代码机器学习开发平台，能够自动完成机器学习的整个工作流。 这个库提供了借助相对工整的数据（无缺失值、类型明确）对一类的机器学习模型（分类、回归、聚类）进行训练，该库能够自己对数据集进行处理，并且能够自动生成模型，除此以外还能进行模型的评价和在测试集上的训练，这些都可以在官方文档中的QuickStart中查看。 这个库非常好的一点在于可以直接根据输入数据来判断数据类型然后作相应的数据处理操作，除此以外它也支持自定义的数据处理操作，这些操作可以在官方文档中的Preprocessing中查看。 最后，这个库也支持对于某一个特定的模型进行调优，这些调优可以在官方文档中的Hyperparameter Tuning中查看。</div></div></div></a><a class="pagination-related" href="/datetime%E6%A8%A1%E5%9D%97/" title="datetime模块"><img class="cover" src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10027.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-02</div><div class="info-item-2">datetime模块</div></div><div class="info-2"><div class="info-item-1">字符串和 Datetime 之间的转换 对于 datetime 模块的所有与时间点相关的对象： 这些对象转化成字符串只需要利用 str 函数（格式化） 也可以利用对象的 strftime（）方法，该方法需要传入参数来指定格式化的形式，规范遵循 ISO C89 compatible（详见 time 模块的时间对象格式化方法）。 通过字符串得到这些对象一般要借助对应类的方法 strptime，这个方法需要传入两个参数，一个参数是要解析的字符串，一个参数是规定了字符串的格式。datetime.strptime('2022-02-10','%Y-%m-%d')需要注意的是两个参数的形式必须完全一致否则会解析错误。 考虑到 strptime（）方法不适用于格式不相同的字符串转化为时间对象，这里可以使用dateutil.parser.parse()函数对一些常见的时间字符串进行自动解析（这个库会在安装 pd 时自动安装），另外也可以调节参数对解析方式微调 from dateutil.parser import...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">爱编程的小明</div><div class="author-info-description">只要不折腾，万般可将就</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kebuAAA"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kebuAAA" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2945190789@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/img/wechat.webp" target="_blank" title="欢迎交流"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如网页加载较慢请尝试魔法上网，博客图文可能无关可以忽略</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9F%E6%9F%A5"><span class="toc-number">1.</span> <span class="toc-text">速查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seaborn-%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">Seaborn 库简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#figure-level-functions"><span class="toc-number">3.</span> <span class="toc-text">Figure-level functions</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BB%98%E5%9B%BE%E5%B0%BA%E5%AF%B8"><span class="toc-number">3.1.</span> <span class="toc-text">指定绘图尺寸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%89%B9%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">两个特例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#axes-level-functions"><span class="toc-number">4.</span> <span class="toc-text">Axes-level functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90-replot"><span class="toc-number">5.</span> <span class="toc-text">统计分析-replot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">数据分布可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E5%88%86%E5%B8%83%E5%92%8C%E8%BE%B9%E7%BC%98%E5%88%86%E5%B8%83%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">联合分布和边缘分布可视化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E5%88%86%E5%B8%83%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">多变量分布可视化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E5%AD%90%E5%9B%BE%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">7.</span> <span class="toc-text">多子图自定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">分类变量可视化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#customization"><span class="toc-number">9.</span> <span class="toc-text">customization</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seaborn-objects"><span class="toc-number">10.</span> <span class="toc-text">seaborn.objects</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E8%B0%83%E6%95%B4"><span class="toc-number">10.1.</span> <span class="toc-text">外观调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#customizing-limits-labels-and-titles"><span class="toc-number">10.1.1.</span> <span class="toc-text">Customizing limits, labels, and titles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#theme-customization"><span class="toc-number">10.1.2.</span> <span class="toc-text">Theme customization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%AD%90%E5%9B%BE%E5%88%9B%E5%BB%BA"><span class="toc-number">10.2.</span> <span class="toc-text">多子图创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88-matplotlib"><span class="toc-number">10.3.</span> <span class="toc-text">结合 matplotlib</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Lasso%E5%9B%9E%E5%BD%92/" title="Lasso回归"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10029.webp" onerror='this.onerror=null,this.src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="Lasso回归"></a><div class="content"><a class="title" href="/Lasso%E5%9B%9E%E5%BD%92/" title="Lasso回归">Lasso回归</a><time datetime="2023-11-14T16:00:00.000Z" title="更新于 2023-11-15 00:00:00">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%B2%AD%E5%9B%9E%E5%BD%92/" title="岭回归"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/岭回归_20231109082818.png" onerror='this.onerror=null,this.src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="岭回归"></a><div class="content"><a class="title" href="/%E5%B2%AD%E5%9B%9E%E5%BD%92/" title="岭回归">岭回归</a><time datetime="2023-11-07T16:00:00.000Z" title="更新于 2023-11-08 00:00:00">2023-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E4%BC%98%E9%9B%85%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88/" title="优雅论文排版"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/优雅论文排版_20230921093206.png" onerror='this.onerror=null,this.src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="优雅论文排版"></a><div class="content"><a class="title" href="/%E4%BC%98%E9%9B%85%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88/" title="优雅论文排版">优雅论文排版</a><time datetime="2023-09-20T16:00:00.000Z" title="更新于 2023-09-21 00:00:00">2023-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" title="多元统计分析"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/多元统计分析_多元正态曲线.png" onerror='this.onerror=null,this.src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="多元统计分析"></a><div class="content"><a class="title" href="/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" title="多元统计分析">多元统计分析</a><time datetime="2023-06-16T02:22:54.000Z" title="更新于 2023-06-16 10:22:54">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Hypothesis%20testing/" title="假设检验"><img src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10008.webp" onerror='this.onerror=null,this.src="https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600"' alt="假设检验"></a><div class="content"><a class="title" href="/Hypothesis%20testing/" title="假设检验">假设检验</a><time datetime="2023-05-09T02:34:00.000Z" title="更新于 2023-05-09 10:34:00">2023-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="/Scripts/js/beijing.js"></script><script src="/Scripts/js/foot_style.js"></script><script src="/Scripts/js/fireworks.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(()=>{window.pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"],cacheBust:!1,analytics:!1,scrollRestoration:!1});const e=e=>{e&&Object.values(e).forEach((e=>e()))};document.addEventListener("pjax:send",(()=>{btf.removeGlobalFnEvent("pjaxSendOnce"),btf.removeGlobalFnEvent("themeChange");const t=document.body.classList;t.contains("read-mode")&&t.remove("read-mode"),e(window.globalFn.pjaxSend)})),document.addEventListener("pjax:complete",(()=>{btf.removeGlobalFnEvent("pjaxCompleteOnce"),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),n=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(n)),e.parentNode.replaceChild(t,e)})),e(window.globalFn.pjaxComplete)})),document.addEventListener("pjax:error",(e=>{if(404===e.request.status){window.location.href=e.request.responseURL}}))})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","0.5s"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>