<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python的抽象魔法--类 | 小明的博客</title><meta name="author" content="爱编程的小明"><meta name="copyright" content="爱编程的小明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#e68ab8"><meta name="description" content="面向对象简介  面向对象使得我们可以只去关注一件事情的参与者就好了，而不用关注参与者以外的东西。 面向对象的好处 一般来说，提及面向对象而不是直接使用全局变量或者函数的好处有以下三个: 多态 多态（..."><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kobal.top/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#e68ab8')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4e3a07c287f8fb6cfc09bf5a7fdc1dd7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "e8bjif1knd");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python的抽象魔法--类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><link rel="stylesheet" href="/Scripts/css/transparent.css"><link rel="stylesheet" href="/Scripts/css/font.css"><link rel="stylesheet" href="/Scripts/css/foot_style.css"><link rel="stylesheet" href="/Scripts/css/twikoo_beautify.css"><link rel="stylesheet" href="/Scripts/css/tags.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="/Scripts/css/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animate.css/4.1.1/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg" style="background-image: url(url(/img/index_img.webp));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/img/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/wallpaper/"><i class="fa-fw fas fa-image fa-fw"></i><span> 壁纸</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fa fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小明的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Python的抽象魔法--类</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/wallpaper/"><i class="fa-fw fas fa-image fa-fw"></i><span> 壁纸</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fa fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Python的抽象魔法--类<a class="post-edit-link" href="https://github.dev/kebuAAA/myblog/blob/main/source/_posts/Python面向对象.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-12T09:42:00.000Z" title="发表于 2022-03-12 17:42:00">2022-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-11T09:42:00.000Z" title="更新于 2023-03-11 17:42:00">2023-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E5%9F%BA%E7%A1%80/">基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="面向对象简介">面向对象简介</h1>
<p><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="./../md_imgs/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/0.png" alt="image.png"></p>
<p>面向对象使得我们可以只去关注一件事情的参与者就好了，而不用关注参与者以外的东西。</p>
<h2 id="面向对象的好处">面向对象的好处</h2>
<p>一般来说，提及面向对象而不是直接使用全局变量或者函数的好处有以下三个:</p>
<h2 id="多态">多态</h2>
<p>多态（ polymorphism）源自希腊语，意思是“有多种形态”。<strong>多态赋予了我们不需要关注对象的类型就可以对其进行操作的能力</strong>。不同对象可以定义相同的方法，进而通过<code>object.method()</code>即可对对象进行操作，只要我们调用的对象拥有我们需要的方法，我们就可以对对象进行操作（操作的行为也会随着对象所属的类而不一样）。<br>
拿方法<code>count()</code>举一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=[<span class="string">&#x27;hello, World&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(x.count(<span class="string">&#x27;e&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>我们并不关心x到底是什么对象（list or str)，我们关心的只是x里边到底有多少个e。只要x里有一个名为 <code>count()</code>的方法，借助这个方法我们能实现我们希望返回的整数，这就足够了。<br>
<strong>每当无需知道对象是什么样的就能对其执行操作时，都是多态在起作用</strong>。</p>
<blockquote>
<p>如果走起来像鸭子，叫起来像鸭子，那么它就是鸭子</p>
</blockquote>
<h2 id="封装">封装</h2>
<p>封装（ encapsulation）指的是向外部隐藏<strong>不必要的细节</strong>。多态让你无需知道对象所属的类（对象的类型）就能调用其方法，而封装让你无需知道对象的<strong>构造</strong>就能使用它。</p>
<h2 id="继承">继承</h2>
<p>在谈继承之前，需要先了解一下类之间的关系。类可以看成是类型的同义词，是python中一种超级数据结构（They’re like super data structures, with code thrown in）<br>
<strong>如果一个类的对象为另一个类的子集，前者就是后者的子类，后者是前者的超类</strong>。</p>
<blockquote>
<p>例如，如果你在窗外看到一只鸟，这只鸟就是“鸟类”的一个实例。鸟类是一个非常通用（抽象）的类，它有多个子类：你看到的那只鸟可能属于子类“云雀”。你可将“鸟类”视为由所有鸟组成的集合，而“云雀”是其一个子集。因此“云雀”为“鸟类”的子类，而“鸟类”为“云雀”的超类</p>
</blockquote>
<p>面向对象的继承是指，<strong>一个类可以继承另一个类的属性和方法</strong>。继承的好处是，子类获得了父类的全部属性和方法，这样就不必从零开始编写，只需要编写新增的属性和方法。这增强了代码的复用性，子类在继承超类时，也可以将超类的方法进行<strong>重写</strong>。</p>
<blockquote>
<p>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。Dog对象可以作为Animal对象对待，但是Animal对象不可以作为Dog对象对待。</p>
</blockquote>
<h3 id="attribute-inheritance-search">Attribute Inheritance Search</h3>
<p>python对属性的搜索遵从以下的原则:</p>
<blockquote>
<p>Find the first occurrence of attribute by looking in object, then in all classes above it,from bottom to top and left to right.<br>
<img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="../md_imgs/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2023-03-12-11-18-33.png" alt=""><br>
<em>l1,l2为两个实例，C1，C2，C3是三个类</em><br>
反应在上图中，当调用<code>l1.att</code>时，搜索的顺序为l1,C1,C2,C3。这样的搜索顺序保证了子类的属性能够覆盖父类的属性，这也是在C1继承C2、C3时，重写x属性的原因。<br>
redefining and replacing the attribute, C1 effectively <strong>customizes</strong> what it inherits from its superclasses.</p>
</blockquote>
<h1 id="类属性和方法">类属性和方法</h1>
<p>类(Class): 用来描述具有相同的属性和方法的<strong>对象(object)<strong>的集合。它定义了该集合中每个对象所共有的属性（attribute）和方法(method)</strong>。对象是类的实例(instance)</strong>。<br>
类属性：类中方法外的变量称为类属性，被该类的所有对象所共享。因为生成的实例中都有一个类指针指向定义的类，因此<strong>所有的实例可以共享该类属性，且类属性可以被访问和直接赋值修改</strong>；类属性定义在类中且在函数体之外。</p>
<blockquote>
<p>实例可以直接访问类属性的取值，但无法直接对其进行修改，直接通过实例属性对其复制会创建一个新的实例属性，而不会修改类属性的值（覆盖类属性），python的属性搜索是自底向上的（instance-&gt;class-&gt;parent class），因此实例属性会覆盖类属性，但是通过类名访问类属性的值不会受到实例属性的影响。</p>
</blockquote>
<p>类的属性定义在类下边，缩进与def命令相同，所有类均可访问该属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">      name = <span class="string">&#x27;Jack&#x27;</span>  <span class="comment">#类属性(公有)</span></span><br><span class="line">      __age = <span class="number">12</span>     <span class="comment">#类属性（私有）</span></span><br></pre></td></tr></table></figure>
<h2 id="类的特殊属性">类的特殊属性</h2>
<p>类的特殊属性：<br>
<strong>dict</strong>：用来获得对象或者实例对象所绑定的所有属性和方法的字典<br>
<strong>class</strong>:对象所属的类<br>
<strong>bases</strong>:对象的父类类型元素<br>
<strong>mro</strong>:类的层次结构<br>
<strong>subclasses</strong>：子类<br>
<strong>doc</strong>：类的注释</p>
<h2 id="类的特殊方法">类的特殊方法</h2>
<ul>
<li><strong><strong>init</strong> :</strong> 对创建的对象进行初始化</li>
<li><strong><strong>del</strong> :</strong> <strong>析构函数，释放对象时使用</strong></li>
<li><strong><strong>repr</strong> :</strong> 打印，转换</li>
<li><strong><strong>setitem</strong> :</strong> 按照索引赋值</li>
<li><strong><strong>getitem</strong>:</strong> 按照索引获取值</li>
<li><strong><strong>len</strong>:</strong> 获得长度</li>
<li><strong><strong>cmp</strong>:</strong> 比较运算</li>
<li><strong><strong>call</strong>:</strong> 函数调用</li>
<li><strong><strong>add</strong>:</strong> 加运算</li>
<li><strong><strong>sub</strong>:</strong> 减运算</li>
<li><strong><strong>mul</strong>:</strong> 乘运算</li>
<li><strong><strong>truediv</strong>:</strong> 除运算</li>
<li><strong><strong>mod</strong>:</strong> 求余运算</li>
<li><strong><strong>pow</strong>:</strong> 乘方</li>
</ul>
<h3 id="init-方法"><strong>init</strong>()方法</h3>
<p>类定义了 <strong>init</strong>() 方法，类的实例化操作会自动调用 <strong>init</strong>() 方法。需要注意的是有的时候可能需要初始化属性，但不确定给该属性赋什么值或者就是想让该属性为空，那么可以给该属性赋值为None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure>
<h3 id="new-方法"><strong>new</strong>()方法</h3>
<p>该方法主要用来写实例的创建方法。<br>
<img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="./../md_imgs/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="image.png"><br>
先通过new方法来创建需要的对象，再通过init方法来初始化对象</p>
<h2 id="类方法和静态方法定义">类方法和静态方法定义</h2>
<p>当我们在解决实际问题时，可能会遇到有一些方法是属于类而不属于实例的方法，如对于一个三角形类，判断输入参数是否是三角形的方法就可以看做是属于类的方法。定义类的私有方法有两个办法，一个办法是利用装饰器<code>@staticmethod</code>定义一个静态方法。另外一种方法是利用装饰器<code>@classmethod</code>用装饰器定义一个类的方法<br>
两者的区别是类方法会默认第一个输入参数是类的名称参数cls（类比self）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line">        self._c = c</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._a + self._b + self._c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        half = self.perimeter() / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sqrt(half * (half - self._a) *</span><br><span class="line">                    (half - self._b) * (half - self._c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    <span class="comment"># 静态方法和类方法都是通过给类发消息来调用的</span></span><br><span class="line">    <span class="keyword">if</span> Triangle.is_valid(a, b, c):</span><br><span class="line">        t = Triangle(a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(t.perimeter())</span><br><span class="line">        <span class="comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span></span><br><span class="line">        <span class="comment"># print(Triangle.perimeter(t))</span></span><br><span class="line">        <span class="built_in">print</span>(t.area())</span><br><span class="line">        <span class="comment"># print(Triangle.area(t))</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法构成三角形.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name=name</span><br><span class="line">        Student.count+=<span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Count</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls.count,<span class="string">&quot;instances have been distributed&quot;</span>)</span><br><span class="line">stu1=Student(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line">Student.Count()</span><br></pre></td></tr></table></figure>
<h2 id="instance">instance</h2>
<p>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</p>
<h3 id="动态语言">动态语言</h3>
<p>Python作为一门动态语言，我们可以根据自己的需要为创建的实例<strong>动态地单独</strong>绑定我们需要的属性和方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My name is Xiaoming&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;my name is %s&quot;</span>%self.name)</span><br><span class="line">stu1=Student(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>)</span><br><span class="line">stu2=Student(<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>)</span><br><span class="line">stu1.print_1=test</span><br><span class="line">stu1.print_1()</span><br><span class="line"><span class="comment">#stu2.print_1()</span></span><br><span class="line"><span class="comment">#AttributeError: &#x27;Student&#x27; object has no attribute &#x27;print_1&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="限制实例属性的绑定">限制实例属性的绑定</h3>
<p>有的时候我们并不希望我们我们对实例可以绑定任意属性，这时我们可以定义<code>__slots__</code>变量来进行限定属性绑定的范围</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    __slots__=(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;&#x27;</span>body<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>对于上述类生成的实例，我们只能绑定age和body两个属性。但需要注意的是这一变量在类的继承时并不会进行继承。</p>
<h2 id="属性或者方法的私有化">属性或者方法的私有化</h2>
<p>在属性和方法定义时前边加上一个&quot;__&quot;可以把类的名称或者属性私有化，私有化之后的类的名称或者属性是不能在外部进行访问的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Site</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, url</span>):</span><br><span class="line">        self.name = name       <span class="comment"># public</span></span><br><span class="line">        self.__url = url   <span class="comment"># private</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;name  : &#x27;</span>, self.name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;url : &#x27;</span>, self.__url)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__foo</span>(<span class="params">self</span>):          <span class="comment"># 私有方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是私有方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):            <span class="comment"># 公共方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是公共方法&#x27;</span>)</span><br><span class="line">        self.__foo()</span><br><span class="line"> </span><br><span class="line">x = Site(<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>)</span><br><span class="line">x.who()        <span class="comment"># 正常输出</span></span><br><span class="line">x.foo()        <span class="comment"># 正常输出</span></span><br><span class="line">x.__foo()      <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="私有属性的访问和更改">私有属性的访问和更改</h3>
<p>在属性或者方法前加’__'可以实现属性私有化，但这也会导致外部代码不能访问该属性（仍然可以通过instance.<em>class name__attribute name访问，实际上是对变量名字进行了重整），于是python添加了一个在类或者属性前加一个’</em>'对类的访问加以限制（虽然仍然可以通过<code>_obj._var</code>实现对该变量的访问，这个符号的含义就是希望我们不要去轻易修改和访问）。但是这样会使得访问和更改都变得比较麻烦，于是python提供了装饰器@property来将有限制的属性或者方法的访问或者修改变得更加便捷。可以理解为将负责把一个方法变成属性进行调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._name=name</span><br><span class="line">        self._age=age</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self,name</span>):</span><br><span class="line">        self._name=name</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line">stu=Person(<span class="string">&#x27;小明&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(stu.name)</span><br><span class="line"><span class="built_in">print</span>(stu.age)</span><br><span class="line">stu.name=<span class="string">&#x27;小王&#x27;</span></span><br><span class="line"><span class="comment">#stu.age=22</span></span><br><span class="line"><span class="built_in">print</span>(stu.name)</span><br><span class="line"><span class="built_in">print</span>(stu.age)</span><br></pre></td></tr></table></figure>
<p><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="./../md_imgs/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" alt="image.png"></p>
<h1 id="基于类的编程">基于类的编程</h1>
<h2 id="类的继承">类的继承</h2>
<p>类的继承使得我们的代码可以实现&quot;自动更新&quot;。继承类的代码格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(<span class="title class_ inherited__">BaseClassName</span>):</span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>
<p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(modname.BaseClassName):</span><br></pre></td></tr></table></figure>
<p>多继承格式与单继承类似,只需在类名称后面的括号内依次写出父类的名称即可,不过需要注意的是当方法在多个父类中出现且有差异时 ,会调用最左边的包含该父类的方法</p>
<blockquote>
<p>Superclasses provide behavior shared by all their subclasses, but because the search proceeds from the bottom up(left right), subclasses may override behavior defined in their superclasses by redefining superclass names lower in the tree</p>
</blockquote>
<h3 id="object类">object类</h3>
<p>object类是所有类的父类，在我们声明类不指明继承的类时，默认继承该类。</p>
<ul>
<li>内置方法dir（）可以查看指定对象的所有属性</li>
<li><strong>str</strong>()，如何打印对象信息，我们经常对该方法进行重写。不进行重写的时候在打印对象的时候会默认输出对象所属的类以及在内存中的位置#return string,不然无效</li>
</ul>
<h3 id="创建自定义类">创建自定义类</h3>
<p>首先引入一个简单的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, world! I&#x27;m &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">foo=Person()</span><br><span class="line"><span class="built_in">print</span>(foo.get_name())</span><br><span class="line">foo.set_name(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>至于self是什么，其实从例子里也能看出，self就是方法的第一个参数，而在这个例子中，每次使用set_name和greet这些方法时，foo都会作为第一个参数传递给这个方法，所以我们用self来命名，因为它指向对象本身。显然， self很有用，甚至必不可少。如果没有它，所有的方法都无法访问对象本身——要操作的属性所属的对象。与以前一样，也可以从外部访问这些属性。 比如可以写<code>print（foo.name）</code></p>
<h3 id="方法覆盖">方法覆盖</h3>
<p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
<p>例如，我们可以通过覆盖父类的方法实现对子类的专有方法进行更改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure>
<h3 id="方法重写">方法重写</h3>
<p>有的时候我们希望对类的方法进行重写时或许希望可以借助原有类的内容，而不是将父类中的方法进行覆盖，这时python中的super()方法提供了这样的一个方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在需要借助父类方法的地方写入</span></span><br><span class="line"><span class="built_in">super</span>().method name(*args,**kwargs)<span class="comment">#不需要写self</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My name is %s&quot;</span>%self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name,ID</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ID=ID</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        <span class="comment">#亦可super(student,self).__init__(name)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My ID is %s&quot;</span>%self.ID)</span><br><span class="line">ming=student(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">88800</span>)</span><br></pre></td></tr></table></figure>
<p>使用<code>super()</code>调用父类方法的一个好处是不需要写父类的名称，这增加了代码的可移植性和重用性。</p>
<h2 id="组合-composition-或聚合-aggregation">组合(composition)或聚合(aggregation)</h2>
<p>类的继承适用于子类和父类存在很多相似点的两个类之间。但还存在一种情况是一个类是另外一个类的组成部分，这时用组合或者聚合是一种不错的选择。比如鸭子有“尾巴”这样的关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hair</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,height</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.height=height</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,hair</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.hair=hair</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ppp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.hair.height)</span><br><span class="line">hair_xiaoming=Hair(<span class="number">88</span>)</span><br><span class="line">stu=Student(hair_xiaoming)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu.hair))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(hair_xiaoming))</span><br><span class="line">stu.ppp()</span><br></pre></td></tr></table></figure>
<h1 id="命名空间和作用域">命名空间和作用域</h1>
<p>在python中，类中变量的作用域与类的方法内的变量的作用域以及类定义外边的作用域是三个独立的作用域，也就是说在这三个域内的变量是互不影响的。如果要在类的方法内部使用类中的变量，需要借助nonlocal对需要使用的作用域进行声明。如果要在类外使用同一变量，则需要用global进行声明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scope_test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_local</span>():</span><br><span class="line">        spam = <span class="string">&quot;local spam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_nonlocal</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> spam</span><br><span class="line">        spam = <span class="string">&quot;nonlocal spam&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_global</span>():</span><br><span class="line">        <span class="keyword">global</span> spam</span><br><span class="line">        spam = <span class="string">&quot;global spam&quot;</span></span><br><span class="line"></span><br><span class="line">    spam = <span class="string">&quot;test spam&quot;</span></span><br><span class="line">    do_local()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After local assignment:&quot;</span>, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After nonlocal assignment:&quot;</span>, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After global assignment:&quot;</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;In global scope:&quot;</span>, spam)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">p</span>():</span><br><span class="line">    <span class="comment">#直接访问会报错的</span></span><br><span class="line">    <span class="comment">#print(a)</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a=<span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">p()</span><br></pre></td></tr></table></figure>
<h2 id="保留用法">‘__’,’_'保留用法</h2>
<p>以两个或者一个下划线开头和结尾的名称都是python的保留用法。<br>
function.__name__:<br>
function.__doc__:</p>
<h1 id="类和模块的使用场景">类和模块的使用场景</h1>
<p><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="./../md_imgs/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png" alt="image.png"></p>
<h1 id="上下文管理器">上下文管理器</h1>
<p>上下文管理器是定义在python中一种特殊的类，它需要有两个特殊的方法，分别是<code>__enter__</code>和<code>__exit__</code>。<br>
<code>with</code>语法块就是一个很好的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</span><br><span class="line">    <span class="keyword">with</span>-body</span><br></pre></td></tr></table></figure>
<p>当使用<code>with</code>语句时，python会自动调用<code>__enter__</code>方法，然后将返回值赋值给<code>as</code>后面的变量，然后执行<code>with-body</code>中的语句，最后调用<code>__exit__</code>方法,换言之，写在context_expression中的类必须有<code>__enter__</code>和<code>__exit__</code>方法，在平时的编程过程中，使用<code>with</code>的场景多见于文件的读写，数据库的连接等,这里简单定义一个上下文管理器然后用<code>with</code>语句来调用它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadFile</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,path</span>):</span><br><span class="line">        self.path=path</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.f_obj = <span class="built_in">open</span>(self.path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;文件读取成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.f_obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">        @exc_type:错误的类型</span></span><br><span class="line"><span class="string">        @exc_val:错误类型对应的值</span></span><br><span class="line"><span class="string">        @exc_tb:代码中错误发生的位置 </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;错误类型：&#x27;</span>, exc_type)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;错误值：&#x27;</span>, exc_val)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;错误位置：&#x27;</span>, exc_tb)</span><br><span class="line">        self.f_obj.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;退出操作&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> ReadFile(<span class="string">&#x27;./test.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#raise SyntaxError</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;对文件数据的处理工作\n打开的文件对象:<span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件是否关闭:<span class="subst">&#123;f.closed&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文件是否关闭:<span class="subst">&#123;f.closed&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无报错运行的结果：</span></span><br><span class="line"><span class="comment"># 文件读取成功</span></span><br><span class="line"><span class="comment"># 对文件数据的处理工作</span></span><br><span class="line"><span class="comment"># 打开的文件对象: &lt; _io.TextIOWrapper name = &#x27;./test.txt&#x27; mode = &#x27;r&#x27; encoding = &#x27;cp936&#x27; &gt;</span></span><br><span class="line"><span class="comment"># 文件是否关闭: False</span></span><br><span class="line"><span class="comment"># 退出操作</span></span><br><span class="line"><span class="comment"># 文件是否关闭: True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有报错运行的情况：</span></span><br><span class="line"><span class="comment"># 文件读取成功</span></span><br><span class="line"><span class="comment"># 出错了</span></span><br><span class="line"><span class="comment"># 错误类型： &lt; class &#x27;SyntaxError&#x27; &gt;</span></span><br><span class="line"><span class="comment"># 错误值： None</span></span><br><span class="line"><span class="comment"># 错误位置： &lt; traceback object at 0x000001D759B21C00 &gt;</span></span><br><span class="line"><span class="comment"># 退出操作</span></span><br></pre></td></tr></table></figure>
<p>实际上，在with<strong>后面的代码块</strong>抛出异常时，exit()方法被执行。开发库时，清理资源，关闭文件等操作，都可以放在exit()方法中。<br>
<code>with</code>语句实际上是对<code>try-except</code>语法的进一步封装，省去了每次在最后写<code>finally</code>语句的麻烦。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kobal.top">爱编程的小明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kobal.top/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">https://kobal.top/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kobal.top" target="_blank">小明的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python%E5%9F%BA%E7%A1%80/">Python基础</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div><div class="post-share"><div class="social-share" data-image="https://www.python.org/static/community_logos/python-logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E5%86%B3%E7%AD%96%E6%A0%91/" title="决策树模型"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10042.webp" onerror="onerror=null;src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">决策树模型</div></div><div class="info-2"><div class="info-item-1">人们的决策过程是一个类似“观察因素A的情况，再根据A的情况观察因素B的情况”的形式，从而形成一种树状结构。决策树学习是模仿人类这一结构化决策过程而发展起来的一种有监督机器学习方法。 它可以被认为是if-then规则的集合，也可以被认为是定义在特征空间和类空间上的条件概率分布。  模型具有可读性 分类速度快  决策树的思想主要来源于Quinlan在1986年提出的ID3和1993提出的C4.5算法，以及由Breiman等人1984年提出的CART算法。 模型  决策树学习本质上是从训练数据集中归纳出一组分类规则或者条件概率模型（在节点处取条件概率最大的进行分类）。决策树问题一般可以分成特征选择、决策树生成、剪枝三部分。  特征选择：通过建立一个函数来衡量特征划分的效果 生成：递归构造决策树的过程 剪枝：递归产生的决策树往往会递归到不能分类为止，这会导致出现过拟合现象，因此需要已经生成的决策树进行剪枝(pruning)，一般是通过极小化决策树整体的损失函数(loss function)或者代价函数(cost...</div></div></div></a><a class="pagination-related" href="/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E5%9F%BA%E7%A1%80/" title="模型评价基础"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10052.webp" onerror="onerror=null;src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">模型评价基础</div></div><div class="info-2"><div class="info-item-1">机器学习训练模型用的数据集和测试数据用的训练集互斥，往往通过测试集的测试误差来近似模型的泛化能力，根据模型的泛化能力评价模型的优劣。 误差是学习器的实际预测输出与样本的真实输出之间的差异。 训练误差，或称经验误差，是学习器在训练集上的误差。 学习器在在新样本上的误差，称为泛化误差。 模型评价主要是根据训练误差和泛化误差，来选择最优的模型及其参数的过程。    回归模型评价方法 6个评价指标：  平均绝对误差：所有样本实际值与预测值差值绝对值和的平均值 均方差（（Mean Squared Error，MSE）：实际值与预测值差的平方的和的平均值 解释回归模型的方差得分（Explained Variance Score）：  explained_variance(y,y^)=1−Var{y−y^}Var{y}explained\_variance(y,\hat{y})=1-\dfrac{Var\{y-\hat{y}...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Counter/" title="Counter"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://www.python.org/static/community_logos/python-logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-07</div><div class="info-item-2">Counter</div></div><div class="info-2"><div class="info-item-1">Counter 是字典类的一个子类可以用来统计可以查数目的对象中元素个数的。 c = Counter()                           # a new, empty counterc = Counter(&#x27;gallahad&#x27;)                 # a new counter from an iterablec = Counter(&#123;&#x27;red&#x27;: 4, &#x27;blue&#x27;: 2&#125;)      # a new counter from a mappingc = Counter(cats=4, dogs=8)             # a new counter from keyword args 对于没有的元素进行查询时会返回 0 而不会报错。 如果要想把一个元素从计数器中移出，要使用del 与字典对象相比，计数器对象还有三个额外的方法：  elements():返回一个和统计结果完全一致的列表。  c = Counter(a=4, b=2, c=0,...</div></div></div></a><a class="pagination-related" href="/Ipython/" title="Ipython"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://www.python.org/static/community_logos/python-logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-04</div><div class="info-item-2">Ipython</div></div><div class="info-2"><div class="info-item-1">IPython 是一种基于 python 的交互式解释器，提供了强大的编辑和交互能力。 对于对象功能的查询操作，Ipython 提供了两种方法：  object?：返回变量的详细信息，查询变量类型或者函数帮助 object??:与上一个功能相似，还可以查看函数或者模块对象的源代码  Ipython 中有一种魔术命令，相当于提供了一种简便进行交互的方式。魔术命令分为两种：  以%开头，是作用于行的魔术命令  %pdoc 打印对象的文档字符串 %quickref#查看语法和魔法命令 %magic:获取所有魔法命令及其用法 %timeit#测量语句的执行时间 %run test.py #运行 python 程序（脚本） %load test.py #导入文件 %paste #从剪切板运行代码 %cpaste #防止粘贴错误，允许查看并运行 %save path n1,n2,n3:保存指定的 cell %bookmark:将常用目录保存为别名，方便使用   以%%开头，表示在整个 cell 单元起作用  %%timeit#测量 cell 的执行时间 %%latex:latex...</div></div></div></a><a class="pagination-related" href="/Python%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF/" title="Python中的下划线"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://www.python.org/static/community_logos/python-logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-08</div><div class="info-item-2">Python中的下划线</div></div><div class="info-2"><div class="info-item-1">Python里经常会出现的下划线的用法汇总</div></div></div></a><a class="pagination-related" href="/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Python数据结构"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://www.python.org/static/community_logos/python-logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="info-item-2">Python数据结构</div></div><div class="info-2"><div class="info-item-1">数据类型  一般来说读写数据常常涉及的两种数据类型是文本数据与二进制数据(图片、语音），Python中对于这两大类数据的操作主要使用其内置的两种数据类型——字符串与字节数组： 字节数组: 8 比特整数组成的序列，用于存储二进制数据。 字符串: Unicode 字符组成的序列，用于存储文本数据 字节 &amp; 字节数组  字节是不可变的，像字节数据组成的元组； 字节数组是可变的，像字节数据组成的列表。 bytes 类型值的表示形式比较特殊：以 b 开头，接着是一个单引号，后面跟着由十六进制数（例如 \x02）或 ASCII 码组成的序列，最后以配对的单引号结束。  a = [1, 2, 1, 3]print(bytes(a))b=bytearray(a)print(b)b.append(3)print(b) 字符串 Unicode Unicode编码是一种国际化的编码方式，存储在其中的每一个字符都有自己独特的名字(帮助理解的标准名称)和标识数(Unicode ID)。 在Python中，我们如果知道某个字符的的Unicode...</div></div></div></a><a class="pagination-related" href="/Python%E8%84%9A%E6%9C%AC/" title="Python脚本"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://www.python.org/static/community_logos/python-logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-17</div><div class="info-item-2">Python脚本</div></div><div class="info-2"><div class="info-item-1">主要用来记录一些比较常用的小脚本，提高工作效率</div></div></div></a><a class="pagination-related" href="/help%E5%A4%A7%E6%B3%95/" title="help大法"><img class="cover" src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://www.python.org/static/community_logos/python-logo.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-09</div><div class="info-item-2">help大法</div></div><div class="info-2"><div class="info-item-1">对Python中出现的各种help方法做一个简单介绍，也作为一个速查手册来使用。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">爱编程的小明</div><div class="author-info-description">只要不折腾，万般可将就</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kebuAAA"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kebuAAA" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/2945190789@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/img/wechat.webp" target="_blank" title="欢迎交流"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如网页加载较慢请尝试魔法上网，博客图文可能无关可以忽略</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">面向对象简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#attribute-inheritance-search"><span class="toc-number">1.4.1.</span> <span class="toc-text">Attribute Inheritance Search</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">类属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">类的特殊属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">类的特殊方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">init()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">new()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text">类方法和静态方法定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instance"><span class="toc-number">2.4.</span> <span class="toc-text">instance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-number">2.4.1.</span> <span class="toc-text">动态语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-number">2.4.2.</span> <span class="toc-text">限制实例属性的绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95%E7%9A%84%E7%A7%81%E6%9C%89%E5%8C%96"><span class="toc-number">2.5.</span> <span class="toc-text">属性或者方法的私有化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE%E5%92%8C%E6%9B%B4%E6%94%B9"><span class="toc-number">2.5.1.</span> <span class="toc-text">私有属性的访问和更改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">基于类的编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">创建自定义类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">方法覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.1.4.</span> <span class="toc-text">方法重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88-composition-%E6%88%96%E8%81%9A%E5%90%88-aggregation"><span class="toc-number">3.2.</span> <span class="toc-text">组合(composition)或聚合(aggregation)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">命名空间和作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">‘__’,’_&#39;保留用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">类和模块的使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">上下文管理器</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Lasso%E5%9B%9E%E5%BD%92/" title="Lasso回归"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10054.webp" onerror="this.onerror=null;this.src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="Lasso回归"/></a><div class="content"><a class="title" href="/Lasso%E5%9B%9E%E5%BD%92/" title="Lasso回归">Lasso回归</a><time datetime="2023-11-14T16:00:00.000Z" title="更新于 2023-11-15 00:00:00">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%B2%AD%E5%9B%9E%E5%BD%92/" title="岭回归"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/岭回归_20231109082818.png" onerror="this.onerror=null;this.src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="岭回归"/></a><div class="content"><a class="title" href="/%E5%B2%AD%E5%9B%9E%E5%BD%92/" title="岭回归">岭回归</a><time datetime="2023-11-07T16:00:00.000Z" title="更新于 2023-11-08 00:00:00">2023-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E4%BC%98%E9%9B%85%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88/" title="优雅论文排版"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/优雅论文排版_20230921093206.png" onerror="this.onerror=null;this.src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="优雅论文排版"/></a><div class="content"><a class="title" href="/%E4%BC%98%E9%9B%85%E8%AE%BA%E6%96%87%E6%8E%92%E7%89%88/" title="优雅论文排版">优雅论文排版</a><time datetime="2023-09-20T16:00:00.000Z" title="更新于 2023-09-21 00:00:00">2023-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" title="多元统计分析"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/多元统计分析_多元正态曲线.png" onerror="this.onerror=null;this.src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="多元统计分析"/></a><div class="content"><a class="title" href="/%E5%A4%9A%E5%85%83%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/" title="多元统计分析">多元统计分析</a><time datetime="2023-06-16T02:22:54.000Z" title="更新于 2023-06-16 10:22:54">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Hypothesis%20testing/" title="假设检验"><img src= "https://gcore.jsdelivr.net/gh/kebuAAA/Picloud@main/img/loading.gif" data-lazy-src="/top_img/10007.webp" onerror="this.onerror=null;this.src='https://images.pexels.com/photos/374918/pexels-photo-374918.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600'" alt="假设检验"/></a><div class="content"><a class="title" href="/Hypothesis%20testing/" title="假设检验">假设检验</a><time datetime="2023-05-09T02:34:00.000Z" title="更新于 2023-05-09 10:34:00">2023-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.kobal.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.kobal.top/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.staticfile.org/twikoo/1.6.22/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/Scripts/js/beijing.js"></script><script src="/Scripts/js/foot_style.js"></script><script src="/Scripts/js/fireworks.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/fireworks.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '0.5s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/wow/1.1.2/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>